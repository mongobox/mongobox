<?php

namespace Emk\Bundle\JukeboxBundle\Entity\Repository;

use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\Query\ResultSetMapping;

/**
 * VideosRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class VideosRepository extends EntityRepository
{
    public function next()
    {
        $q = $this
                ->createQueryBuilder('v')
                ->select('v')
                ->where('v.done = 0')
                ->orderBy('v.date', 'ASC')
                ->setMaxResults(1)
                ->getQuery()
        ;

        $result = $q->getOneOrNullResult();

        //Si il n'y en a plus à passer, on fait un random
        if (is_null($result)) {
            $result = $this->random();
        }

        return $result;
    }

    public function random()
    {
        $em = $this->getEntityManager();
        $date = new \Datetime();
        $day = $date->format('w');
        if($day != 5) $where = 'v.vendredi = false';
        else $where = '1';

        $rsm = new ResultSetMapping();
        $rsm->addEntityResult('Emk\Bundle\JukeboxBundle\Entity\Videos', 'v');
        $rsm->addFieldResult('v', 'lien', 'lien');
        $rsm->addFieldResult('v', 'id', 'id');
        $rsm->addFieldResult('v', 'duration', 'duration');
        $rsm->addFieldResult('v', 'title', 'title');
        $rsm->addFieldResult('v', 'diffusion', 'diffusion');
        $rsm->addFieldResult('v', 'last_broadcast', 'lastBroadcast');
        $rsm->addFieldResult('v', 'done', 'done');
        $rsm->addFieldResult('v', 'date', 'date');
        $q = $em
                ->createNativeQuery('SELECT * FROM videos v LEFT JOIN playlist p ON p.id_video = v.id WHERE '.$where.' AND (DATE(v.last_broadcast) < DATE(NOW()) OR v.last_broadcast IS NULL) AND p.id_video IS NULL', $rsm);

        $results = $q->getResult();
        if (count($results) > 0) {
            $songs = array();
            foreach ($results as $song) {
                $songs[] = $song->getDiffusion() - $song->getVotes();
            }
            $max = max($songs);

            $songs = array();
            foreach ($results as $song) {
                $value = $max - ($song->getDiffusion() - $song->getVotes()) + 1;
                $songs[$song->getId()] = $value;
            }

            $rand = $this->getRandomWeightedElement($songs);
            $video = $em->getRepository('EmkJukeboxBundle:Videos')->find($rand);

            return $video;
        } else return null;
    }

    /**
     * Fonction de recherche des vidéos
     * 
     * @param unknown_type $search
     * @param unknown_type $page
     * @param unknown_type $limit
     * @param unknown_type $filters
     * @return unknown
     */
    public function search($search, $page, $limit, $filters )
    {
        $q = $this
                ->createQueryBuilder('v')
                ->select('v')
                ->orderBy('v.'. $filters['sortBy'], strtoupper($filters['orderBy']) )
                ->setMaxResults($limit)
                ->setFirstResult($limit * ($page-1));

        if (array_key_exists('title', $search)) {
            $q
                ->where('v.title LIKE :title')
                ->setParameter('title', '%'.$search['title'].'%');
        }
        
        
        $q = $q->getQuery();

        $result = $q->getResult();

        return $result;
    }

    /**
    * getRandomWeightedElement()
    * Utility function for getting random values with weighting.
    * Pass in an associative array, such as array('A'=>5, 'B'=>45, 'C'=>50)
    * An array like this means that "A" has a 5% chance of being selected, "B" 45%, and "C" 50%.
    * The return value is the array key, A, B, or C in this case.  Note that the values assigned
    * do not have to be percentages.  The values are simply relative to each other.  If one value
    * weight was 2, and the other weight of 1, the value with the weight of 2 has about a 66%
    * chance of being selected.  Also note that weights should be integers.
    *
    * @param array $weightedValues
    */
    public function getRandomWeightedElement(array $weightedValues)
    {
        $rand = mt_rand(1, (int) array_sum($weightedValues));

        foreach ($weightedValues as $key => $value) {
            $rand -= $value;
            if ($rand <= 0) {
                return $key;
            }
        }
    }
}
